<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vanGona</title>
    <description>임상심리학자가 개발을 추구하는 건에 대해서
</description>
    <link>http://vangona.github.io/</link>
    <atom:link href="http://vangona.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 13 Dec 2022 15:37:33 +0900</pubDate>
    <lastBuildDate>Tue, 13 Dec 2022 15:37:33 +0900</lastBuildDate>
    <generator>Jekyll v3.9.2</generator>
    
      <item>
        <title>누군가의 서랍장</title>
        <description>&lt;h1 id=&quot;누군가의-서랍장&quot;&gt;&lt;center&gt;누군가의 서랍장&lt;/center&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/207241570-87e8813c-5176-47c4-8dc0-1c2fac3c52c4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-생각정리를-위한-공간과-책-그리고-sns&quot;&gt;/ 생각정리를 위한, 공간과 책 그리고 SNS&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;1-생각정리를-위한-공간&quot;&gt;1. 생각정리를 위한 공간&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/207241725-7cd252e9-ee1a-4d1f-80c8-75da063c05cc.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 질문에서 시작했습니다.
사람들이 생각할 여유를 만들고 싶었습니다.&lt;/p&gt;

&lt;p&gt;프로젝트 기획자는 생각 정리를 위한 공간을 운영하고 있습니다.&lt;/p&gt;

&lt;p&gt;누군가는 이곳에서 복잡한 머리를,
누군가는 답답한 감정을,
누군가는 묻혀있던 바램을 정리합니다.&lt;/p&gt;

&lt;p&gt;그리고 이곳에서 글, 그림, 사진 또는 무언가로
정리된 생각들을 모아 책을 만들고 있습니다.
도움이 되길 바라며 질문을 더해서요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하늘의 색을 기억하고 계신가요?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;당신께 행복은 무엇이신가요?&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-생각정리를-위한-책-나만의-서랍장&quot;&gt;2. 생각정리를 위한 책, 나만의 서랍장&lt;/h3&gt;

&lt;p&gt;사람은 때로 일기를 쓰거나 질문지를 쓰며 생각을 정리하려는 시도를 합니다.
몇몇 생각에는 감정과 바램이 함께 담겨있기 때문에 혼자서 정리가 어렵습니다.
그래서 자기연민에 빠지거나 자신의 생각에 갇혀버리기도 합니다.
그건 어렵고 아픈 과정입니다. 돕고 싶었습니다.&lt;/p&gt;

&lt;p&gt;50여명의 사람들이 정리한 100여개의 생각들을 추려 책으로 엮었습니다.
적절한 질문과 답변 페이지를 두어서, 책을 읽으며 떠오른 자신의 생각을
정리할 수 있도록 돕습니다. 위로를 받되 스스로에게 갇히지 않으면서요.&lt;/p&gt;

&lt;p&gt;정답을 쓰려 하지 말고, 질문을 보고
떠오르는 것들을 다 적은 다음
그다음 버릴 생각을 버리고,
예쁘게 정리하시면 됩니다.&lt;/p&gt;

&lt;p&gt;생각에 얽매이지도, 피하지도 않도록 잘 정리해두는
나만의 서랍장인 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;영감은 대단한 것이 아니라 솔직한 곳에서 온다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-정리된-생각을-나누는-sns&quot;&gt;3. 정리된 생각을 나누는 SNS&lt;/h3&gt;

&lt;h2 id=&quot;-창업-과정&quot;&gt;/ 창업 과정&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;청년창업지원사업&quot;&gt;청년창업지원사업&lt;/h3&gt;

&lt;h3 id=&quot;공간을-만들기&quot;&gt;공간을 만들기&lt;/h3&gt;

&lt;h3 id=&quot;책을-만들기&quot;&gt;책을 만들기&lt;/h3&gt;

&lt;h3 id=&quot;코로나와-sns&quot;&gt;코로나와 SNS&lt;/h3&gt;

&lt;h2 id=&quot;-폐업-신고&quot;&gt;/ 폐업 신고&lt;/h2&gt;

&lt;p&gt;무언가를 포기해야 하는 도전을 할 때는, 포기해야 하는 것보다 더 얻을게 있는 것 같다는 판단이 섰을 때 도전했다. 내 나이에서 우선순위는 성취보다 배움이 먼저라고 생각했다.&lt;/p&gt;

&lt;p&gt;창업지원사업에 지원하며 기대했던 것은 좋은 실패였다.&lt;/p&gt;

&lt;p&gt;성공에 대한 기대는 분명 있었다. ‘나는 부자가 될거야!’ 라는 기대보다는, 나의 비전과 가치관에 맞는 무언가를 새롭게 만들어서 가치전달 한다는 것 때문에 창업이 끌렸다.&lt;/p&gt;

&lt;p&gt;다만 창업의 선택은 많은 것을 포기해야 하는 것이었는데, ‘상담을 전공하는 대학생, 놀라운 아이디어로 한 번에 사업 성공을 거두다!’ 같이 꿈 같은 확률을 쫓는 것은 적어도 나한테는 타산이 안 맞았다.&lt;/p&gt;

&lt;p&gt;창업의 평균 지속률은 매우 낮았고, 그 이야기는 창업이 자신감과 노력만으로 되는 것은 아니라는 것이었다.&lt;/p&gt;

&lt;p&gt;성공한 사람들은 한 번 이상의 실패를 겪었다는 통계적 사실이 있었다. 시행착오 없는 성공은 불안정한 모래성 같았다는 경험적 사실이 있었다.&lt;/p&gt;

&lt;p&gt;그런 사고 과정으로 나는 첫 창업을 통해 배워야 하는 가장 중요한 배움은 창업 실패라는 요상한 결론을 내렸다.&lt;/p&gt;

&lt;p&gt;좋은 실패를 위해서 열심히 할 수 있었다. 많은 돈이 들어가거나 인력이 더 필요하지 않은 사이클의 개괄적인 작업은 모두 해봤다. 기획, 사업계획서, 지원사업진행, 예산 사용, 서비스 운영, 고객 응대, 서비스 개선, 디자인, 제품 생산과 온라인 판매, 웹 개발까지 해봤다.&lt;/p&gt;

&lt;p&gt;내 자본이 들어가지 않았음에도 실패에 대해 내가 충분히 슬퍼할 수 있었던 이유는 아마도 일정수준 이상의 노력과 적절한 성공, 적절한 실패와 내 행동의 이유에 대한 완고함, 그리고 그 모든 것이 어쩌면 기획단계부터 틀렸다는 것을 받아들이는 과정을 모두 겪었기 때문인 것 같다.&lt;/p&gt;

&lt;p&gt;이런 과정을 통해 실패를 해본 사람과 해보지 않은 사람의 차이를 아주 조금 이해하게 된다. 가치는 완벽한 기획안이 아니라 끊임없는 개선에서 온다는 애자일 방법론에 대한 체험적인 이해다.&lt;/p&gt;

&lt;p&gt;비즈니스로 보면 시장에 대한 겸손함일 수도 있겠고, 심리학으로 보면 삶의 행복은 단 순간의 성취가 아니라 가치를 정하고 계속 개선해나가며 생기는 꾸준한 안정감을 통해서 온다는 삶의 조각에 대한 깨달음이었을 수도 있겠다.&lt;/p&gt;

&lt;p&gt;나는 이렇게 폐업 신고를 하며 나의 첫 창업이 성공적이었다고 쓴다. 행복은 견고한 일상에 영감 한 스푼. 여전히 내 꿈은 행복한 사람이다.&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Dec 2022 00:00:00 +0900</pubDate>
        <link>http://vangona.github.io/posts/your-own-drawer</link>
        <guid isPermaLink="true">http://vangona.github.io/posts/your-own-drawer</guid>
        
        <category>누군가의 서랍장</category>
        
        <category>크라우드펀딩</category>
        
        <category>지식공유</category>
        
        
        <category>Projects</category>
        
      </item>
    
      <item>
        <title>와글와글 Parallax 스크롤</title>
        <description>&lt;h1 id=&quot;와글와글-parallax-스크롤-도입기&quot;&gt;&lt;center&gt;와글와글 Parallax 스크롤 도입기&lt;/center&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/207240377-1d732c76-7d1c-439e-9ddf-4a67be2f11c5.gif&quot; alt=&quot;scroll-animation (1)&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-스크롤-애니메이션-도입기&quot;&gt;❓ 스크롤 애니메이션 도입기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;랜딩페이지에 단순한 설명이 적혀있으면 설명이 읽히지 않을 것이라고 생각했다.&lt;/li&gt;
  &lt;li&gt;캠퍼분들께 데모 사이트를 공유할 때, 가능하다면 어떤 것을 위한 서비스인지 전달할 수 있으면 좋겠다고 생각했다.&lt;/li&gt;
  &lt;li&gt;데모 사이트를 공유하는 글에 서비스 소개가 적히면, 글이 무거워져서 유저가 진입하기 어렵다고 판단했다.&lt;/li&gt;
  &lt;li&gt;사용하는 사람들이 흥미롭게 읽어볼 수 있는 소개 사이트를 만들기 위해 상호작용이 가능한 스크롤 애니메이션을 구현해보았다.&lt;/li&gt;
  &lt;li&gt;또한 유저가 소개글에 몰입하여 서비스와 유대감이 생길 수 있도록 Parallax 스크롤을 구현했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;️-과정--intersection-observer-svg-parallax&quot;&gt;🛤️ 과정 : Intersection Observer, SVG, Parallax&lt;/h2&gt;

&lt;h3 id=&quot;intersection-observer-api&quot;&gt;Intersection Observer API&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Intersection Observer를 통해 설명 섹션의 절반 이상을 지나면 이벤트가 발생할 수 있도록 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;svg-path-따라-그리기-svg-dashoffset과-dasharray&quot;&gt;SVG path 따라 그리기 (SVG dashoffset과 dasharray)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;단순히 글자의 opacity를 바꾼다거나 slide-in 하는 것은 흥미를 끌기 어려웠고, 너무 화려한 애니메이션은 서비스의 성격과 맞지 않았고, 글자가 자연스럽게 써지는 효과가 있으면 좋겠다고 생각해서 구현하게 되었다.&lt;/li&gt;
  &lt;li&gt;SVG dashoffset과 dasharray 속성을 이용하여 SVG의 path를 자연스럽게 그릴 수 있었다.&lt;/li&gt;
  &lt;li&gt;이러한 속성과 Intersection Observer를 활용하여 유저의 스크롤에 반응하는 스크롤 애니메이션을 구현했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;시차-스크롤-parallax-scroll&quot;&gt;시차 스크롤 (Parallax Scroll)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;처음에는 background-attachment 속성을 이용하여 전체 배경 이미지에 parallax를 사용하려했으나, 구현하고나니 서비스 소개와 맞지 않는다는 것을 알게되었습니다. 가벼운 느낌의 서비스 소개와 어울릴 수 있도록 간단한 이미지와 사용할 수 있어야 했습니다. 이를 위해서 시차를 직접 구현했다.&lt;/li&gt;
  &lt;li&gt;window scroll 이벤트에 window.scrollY를 리액트의 상태로 저장하고, 이 상태에 따라서 특정 이미지를 transform translateY을 사용해서 스크롤에 따라 이동할 수 있도록 했다.&lt;/li&gt;
  &lt;li&gt;여기에서 window.scrollY와 1:1로 이동하는 것이 아니라 비율을 조정하여 원근감이 있는 것처럼 보이도록 구현할 수 있었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과--ux적으로-몰입감-있는-서비스-소개&quot;&gt;❗결과 : UX적으로 몰입감 있는 서비스 소개&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;데모를 배포할 때, 소개글을 따로 추가하지 않아도 되어서 글이 가볍게 공유될 수 있었고 기대치인 30명보다 더 많은 47명의 사람들이 방문했다.&lt;/li&gt;
  &lt;li&gt;지루할 수 있는 서비스 소개에 대해서 많은 유저분들이 끝까지 읽어주셨고, 스크롤 애니메이션과 서비스에 대해 피드백을 받아볼 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 06 Dec 2022 00:00:00 +0900</pubDate>
        <link>http://vangona.github.io/posts/waglewagle-parellex-scroll</link>
        <guid isPermaLink="true">http://vangona.github.io/posts/waglewagle-parellex-scroll</guid>
        
        <category>와글와글</category>
        
        <category>Parellex</category>
        
        <category>UX</category>
        
        
        <category>Projects</category>
        
      </item>
    
      <item>
        <title>와글와글 성능 최적화</title>
        <description>&lt;h1 id=&quot;라이트-하우스-점수-개선&quot;&gt;라이트 하우스 점수 개선&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/207239469-4cdf7b57-925c-454a-96ae-c265205f6bfc.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Next.js의 코드스플리팅, SSR, SSG과 폰트 파일 압축 및 캐싱을 통해 성능 점수를 &lt;strong&gt;60점&lt;/strong&gt;에서 &lt;strong&gt;94점으로 개선&lt;/strong&gt;할 수 있었다.&lt;/li&gt;
  &lt;li&gt;스크린 리더에 기본 언어를 명시하고자 lang 태그를 사용하고 배경색과 글자색의 대비를 높여 접근성 점수를 &lt;strong&gt;73점&lt;/strong&gt;에서 &lt;strong&gt;100점으로 개선&lt;/strong&gt;할 수 있었다.&lt;/li&gt;
  &lt;li&gt;meta 태그와 라이트하우스 SEO 점수를 &lt;strong&gt;85점&lt;/strong&gt;에서 &lt;strong&gt;100점으로 개선&lt;/strong&gt;할 수 있었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;크롬-개발자-도구-성능-측정-및-개선&quot;&gt;크롬 개발자 도구 성능 측정 및 개선&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;크롬 개발자 도구를 통해서 버블차트의 특정 상태로 인해 사용되지 않는 EventListener가 지속적으로 쌓이고 있는 버그를 발견, 해당 상태를 제거하는 로직으로 버그를 해결하여 &lt;strong&gt;최대 800&lt;/strong&gt;까지 쌓이던 EventListener를 &lt;strong&gt;400 이하로 유지&lt;/strong&gt;하고 &lt;strong&gt;JS Heap 메모리&lt;/strong&gt;를 &lt;strong&gt;최대 60mb&lt;/strong&gt;에서 &lt;strong&gt;35mb로 감소&lt;/strong&gt;시킬 수 있었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;api-데이터-리렌더링-성능-개선&quot;&gt;API 데이터 리렌더링 성능 개선&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;서비스에 맞는 실시간성을 유지하기 위해서 Short Polling을 사용하였습니다. 그리고 이에 따라서 요청 주기마다 API 응답에 의해 리렌더링이 발생했다.&lt;/li&gt;
  &lt;li&gt;Tanstack Query의 Caching 기능과 렌더링 최적화를 통해서 &lt;strong&gt;1초마다 발생하던 리렌더링&lt;/strong&gt;을 *&lt;em&gt;데이터가 변경되었을 때만 하도록 개선&lt;/em&gt; 할 수 있었다.&lt;/li&gt;
  &lt;li&gt;이후 UI 로직을 수정하여, 변경된 데이터가 수신되었더라도 &lt;strong&gt;전체 버블차트가 리렌더링&lt;/strong&gt; 되는 것이 아니라 &lt;strong&gt;변경된 키워드 버블만 리렌더링&lt;/strong&gt; &lt;strong&gt;될 수 있도록 최적화&lt;/strong&gt;시킬 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 06 Dec 2022 00:00:00 +0900</pubDate>
        <link>http://vangona.github.io/posts/waglewagle-optimization</link>
        <guid isPermaLink="true">http://vangona.github.io/posts/waglewagle-optimization</guid>
        
        <category>와글와글</category>
        
        <category>라이트하우스</category>
        
        <category>크롬 개발자 도구</category>
        
        <category>Tanstack Query</category>
        
        
        <category>Projects</category>
        
      </item>
    
      <item>
        <title>와글와글 Next.js 서버 배포와 CI / CD 적용기</title>
        <description>&lt;h1 id=&quot;nextjs&quot;&gt;Next.js&lt;/h1&gt;

&lt;h1 id=&quot;bff&quot;&gt;BFF&lt;/h1&gt;

&lt;h1 id=&quot;ci--cd&quot;&gt;CI / CD&lt;/h1&gt;
</description>
        <pubDate>Tue, 06 Dec 2022 00:00:00 +0900</pubDate>
        <link>http://vangona.github.io/posts/waglewagle-bff-deploy</link>
        <guid isPermaLink="true">http://vangona.github.io/posts/waglewagle-bff-deploy</guid>
        
        <category>와글와글</category>
        
        <category>Next.js</category>
        
        <category>CI / CD</category>
        
        
        <category>Projects</category>
        
      </item>
    
      <item>
        <title>Trie 자료구조를 활용한 검색엔진 만들기</title>
        <description>&lt;h1 id=&quot;trie-자료구조로-자동완성-검색엔진-만들기&quot;&gt;&lt;center&gt;Trie 자료구조로 자동완성 검색엔진 만들기&lt;/center&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/207239708-2ec55698-4d49-476b-b0b8-e68ca5fd9093.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;problem&quot;&gt;Problem&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;소그룹의 활성도를 위해 키워드를 등록하고자 할 때 비슷한 키워드의 중복 생성 방지하여 그룹의 인원이 분할되지 않도록 하는 작업이 필요하게 되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;think&quot;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;처음에는 정규 표현식을 통해서 검색어가 바뀔 때마다 모든 키워드를 탐색하고자 하였으나 성능적으로 비효율 적이라고 생각되어서 알고리즘의 변화가 필요했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;검색 엔진에서 사용되는 알고리즘들을 조사, 비교하여 현재 프로젝트에 가장 적절한 알고리즘을 결정했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;process&quot;&gt;Process&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;정규 표현식과, 이진 탐색, 트라이 등의 방법을 고려하여 시간 복잡도를 분석하니 아래와 같은 결과가 나왔다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;N = 단어의 개수, M = 문자열 길이&lt;/th&gt;
      &lt;th&gt;사전 작업 시간 복잡도&lt;/th&gt;
      &lt;th&gt;탐색 시간 복잡도&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;전체 탐색(정규 표현식)&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;O(M * N)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;이진 탐색&lt;/td&gt;
      &lt;td&gt;O(N _ M _ logN) (정렬)&lt;/td&gt;
      &lt;td&gt;O(M * logN)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;트라이&lt;/td&gt;
      &lt;td&gt;O(N * M) (트라이 생성)&lt;/td&gt;
      &lt;td&gt;O(M)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;result&quot;&gt;Result&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;사전 생성 시간이 있고, 메모리를 많이 차지하는 단점이 있지만, 커뮤니티 접속 시 한번만 실행하면 되고, 탐색이 빈번하게 발생하는 검색 엔진 특성상 트라이가 가장 효율적이라고 결론을 내릴 수 있었다.&lt;/li&gt;
  &lt;li&gt;결과적으로 탐색 시간 복잡도를 O(M * N)에서 O(M)까지 감소시킬 수 있었다.(M: 문자열 길이, N: 단어의 개수)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 06 Dec 2022 00:00:00 +0900</pubDate>
        <link>http://vangona.github.io/posts/trie-search-engine</link>
        <guid isPermaLink="true">http://vangona.github.io/posts/trie-search-engine</guid>
        
        <category>와글와글</category>
        
        <category>2차원 배치</category>
        
        <category>물리엔진</category>
        
        
        <category>Projects</category>
        
      </item>
    
      <item>
        <title>와글와글 데이터 시각화를 위한 2차원 배치 물리엔진 만들기</title>
        <description>&lt;h1 id=&quot;2차원-데이터-시각화를-해봅시다&quot;&gt;&lt;center&gt;2차원 데이터 시각화를 해봅시다.&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;문제의-발생과-접근&quot;&gt;문제의 발생과 접근&lt;/h2&gt;

&lt;h3 id=&quot;데이터-시각화-기술적인-도전이란-무엇일까&quot;&gt;데이터 시각화, 기술적인 도전이란 무엇일까?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;프로젝트를 진행하며 데이터 시각화(워드 클라우드)를 위한 라이브러리를 찾던 중, 프로젝트에 어울리는 방식으로 동작하는 데이터 시각화 라이브러리를 찾기가 어려웠다.&lt;/li&gt;
  &lt;li&gt;필요한 동작에 비해 렌더링까지 라이브러리에서 맡고 있어서 UI 로직과의 분리가 어려워 리액트와의 합이 좋지 않거나, d3처럼 하나의 기능을 위해서 규모가 커졌다.&lt;/li&gt;
  &lt;li&gt;데이터 시각화를 해주는 로직을 모른다면, 제대로 쓰고 있지 않다는 생각도 있었다. 핵심기능에 대한 기술적인 도전이라함은 단순히 라이브러리를 쓰는 것이 아니라 원리를 이해하는 것이라고 생각했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;문제-접근-탐구와-이해를-선호합니다&quot;&gt;문제 접근, 탐구와 이해를 선호합니다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;방법은 두 가지라고 생각했다. 하나는 라이브러리를 뜯어서 내부로직을 이해하면서 쓰는 것이고, 하나는 직접 만들어보는 쪽이었다.&lt;/li&gt;
  &lt;li&gt;생각은 직접 만들어보는 쪽으로 움직였다.&lt;/li&gt;
  &lt;li&gt;라이브러리를 뜯어서 본다면, 해당 라이브러리를 이해하게 되겠지만 우리가 직접 만들어본다면, 데이터 시각화에 대해 많은 것을 배울 수도 우리의 프로젝트에 맞게도 만들 수 있지 않을까?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2차원-배치-알고리즘&quot;&gt;2차원 배치 알고리즘&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/206626971-2812c98e-a7fc-40db-a397-f3d4792ca0fb.png&quot; alt=&quot;image&quot; /&gt;
(팀원분의 달팽이 순회로 2차원 사각형 적재 알고리즘 설계)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;처음에는 워드 클라우드의 형태로 만드려고 했었다보니, 2차원 사각형 적재 알고리즘을 중심으로 자료를 찾아보았다.&lt;/li&gt;
  &lt;li&gt;하지만 이내 문제가 생겼는데 유저들의 키워드 관심사가 일정 수준 이상으로 길어진다면, 워드클라우드가 예쁘지 않다는 것이었다.&lt;/li&gt;
  &lt;li&gt;워드클라우드는 공간을 꼼꼼히 채워 시각적인 완성감을 주는데, 그러기 위해서 긴 단어를 회전 시키는 등 2차원 사각형 적재 알고리즘을 사용한다.&lt;/li&gt;
  &lt;li&gt;우리는 단순히 워드클라우드를 만드는 것이 아니라, 이것을 읽고 관심사로 생각하고 입장할 수 있어야했는데 회전을 시키는 것은 UX적으로 좋지 않다는 생각이 들었다.&lt;/li&gt;
  &lt;li&gt;또한 회전을 시키지 않는다면, 글자가 길어진다면 사각형을 채워넣을 때 빈 공간이 애매해진다는 단점이 있었다.&lt;/li&gt;
  &lt;li&gt;글자 수가 긴 글자가 글자 수가 짧고 인원 수가 많은 키워드보다 돋보일 수도 있다는 문제점도 있었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;우리-버블-차트로-바꿉시다&quot;&gt;우리 버블 차트로 바꿉시다.&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/206628218-17ffeba8-b5d0-4a06-90fe-7f5a423c6aa0.png&quot; alt=&quot;image&quot; /&gt;
(버블차트 예시)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버블 차트로 바꾼다면 어떨까? 버블 차트로 바꾼다면 위의 문제들이 해결되었다. 멤버수에 따라 radius를 주면 되고, 글자가 길어진다고 해도 키워드 버블 내부에 flex: wrap; 등으로 줄바꿈을 해주거나 elipsis 옵션을 주어서 해결할 수 있다고 생각했다.&lt;/li&gt;
  &lt;li&gt;가독성도 더 좋아질 것 같았고, 더 ‘와글와글’한 UX를 줄 수 있다고 생각되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;물리엔진의-도입&quot;&gt;물리엔진의 도입&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;처음에는 2차원 원형 적재 알고리즘을 사용하여 구현하려고 했으나, 2차원 원형 적재 알고리즘도 결국 겹침을 확인하고 일정 경로를 이동하여 다시 겹침을 확인해서 배치하는 것의 반복이었다. 이렇게 버블을 배치하면 인터랙티브한 데이터 시각화가 어렵고 유저 입장에서 UX가 지루할 수 있다는 생각이 들었다.&lt;/li&gt;
  &lt;li&gt;물리엔진을 통해서 2차원 원형 배치를 구현한다면, 충돌력과 중력, 반발력등을 통해서 랜덤하고 동적인 변화를 준다면 지루해보일 수 있다는 문제를 해결할 수 있다는 아이디어가 떠올랐다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;레퍼런스-라이브러리-찾아보기&quot;&gt;레퍼런스 라이브러리 찾아보기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/206628520-9aac69e8-987d-44bc-a58d-c9a86dcaf49e.gif&quot; alt=&quot;image&quot; /&gt;
(circlepacker 라이브러리 - 내부적으로 물리엔진이 있다.)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실제로 우리가 생각한 이미지가 잘맞을지 기존의 여러 라이브러리를 찾아보았다.&lt;/li&gt;
  &lt;li&gt;물리엔진을 구현한 matter.js 등이 있었는데, matter.js는 정말로 물리를 구현하기 위한 것이라서 프로젝트의 버블 차트와는 맞지 않았다. 사용하면 구현은 가능하겠지만, 프론트 엔드 개발이 아닌 matter.js 공부를 하게 될 것이라는 판단이었다.&lt;/li&gt;
  &lt;li&gt;circlepacker라는 라이브러리가 있었는데, 해당 라이브러리는 자성을 주어서 circle이 멈추게 하는 정말 원형 적재를 위한 라이브러리였다.&lt;/li&gt;
  &lt;li&gt;다만 확실히 우리가 바라는 동적인 느낌을 줄 수 있겠다는 생각이 들었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;연산만-하게-만듭시다&quot;&gt;연산만 하게 만듭시다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;우리가 리액트를 사용하고 있으니, 이 물리엔진이 canvas등을 통해서 화면에 그리게까지 만드는 것보다는 연산 로직만 담당하도록 만드는 것이 낫겠다는 판단을 했다.&lt;/li&gt;
  &lt;li&gt;이렇게 한다면 이후 canvas, 직접 DOM 렌더링, 리액트 렌더링 등 여러 렌더링 방식의 성능을 비교해보기도 좋을 것 같았고 리액트의 설계 배경에 더 잘 맞았다.&lt;/li&gt;
  &lt;li&gt;리액트의 동작원리를 생각해보면, 애니메이션이니 무조건 canvas를 쓰는 것보다 DOM 객체 정보를 활용하며 리렌더링을 하는 것이 오히려 성능상 이점을 가져올 수도 있다는 생각도 있었다.&lt;/li&gt;
  &lt;li&gt;디버깅을 할 때 UI로직과 연산 로직이 분리되어 있으니 수월할 것이라는 판단도 있었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;그럼-이제-물리엔진을-만들어봅시다&quot;&gt;그럼 이제 물리엔진을 만들어봅시다.&lt;/h1&gt;

&lt;h2 id=&quot;ui를-먼저-그리기-프론트엔드의-장점&quot;&gt;UI를 먼저 그리기, 프론트엔드의 장점&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/203589182-59f36ad2-6a8f-445b-b017-3ea87e816b01.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;만들 예정인 버블 차트의 UI를 우선 리액트 컴포넌트로 먼저 만들고, radius, X 좌표, Y 좌표를 상태로 두어서 위치와 크기를 동적으로 변경할 수 있도록 했다. 이후 연산된 좌표가 제대로 동작하고 있는지를 시각적으로 보기 위함이었다.&lt;/li&gt;
  &lt;li&gt;프론트엔드에서는 이렇게 UI를 만들어두면 연산이 제대로 동작하고 있는지 마치 테스트 코드와 유사하게 볼 수 있는 이점이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;물리엔진의-시작-속도를-만들기&quot;&gt;물리엔진의 시작, 속도를 만들기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/206630630-1b81c5f6-f744-4815-8011-679a184f3add.gif&quot; alt=&quot;203851155-26e145d2-f7d7-44b8-b95d-f45263007d71&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일단 우리 프로젝트에 필요한 힘을 생각해보고, 속도와 마찰력 충돌력을 중심으로 물리엔진을 구현하기로 했다.&lt;/li&gt;
  &lt;li&gt;원들의 상태와 충돌등을 구현하고 이해하기 쉽도록 객체지향으로 구현하였다.&lt;/li&gt;
  &lt;li&gt;초기의 위치는 전체 container의 넓이와 높이에 랜덤으로 설정하게 해주었으며, 해당 위치에서 중심점으로 초기 벡터를 가지고 움직이도록 하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;자연스러운-움직임을-위해-힘을-만들기&quot;&gt;자연스러운 움직임을 위해 힘을 만들기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;마찰력은 현재의 속력을 잃게 만드는 힘, 충돌력은 겹침이 발생했을 때 겹침을 해소하는 힘이라고 개념적인 모델링을 하고 물리엔진을 구현하였다.&lt;/li&gt;
  &lt;li&gt;각각의 힘은 계수를 정해주어 이후에 변경이 쉽게 만들었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;수학과-과학의-도움을-받기&quot;&gt;수학과 과학의 도움을 받기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;마찰력은 진행중인 벡터의 양을 줄여주어서 해결할 수 있었는데, 자연스러운 충돌을 위해서는 충돌량이 어떻게 발생하는지에 대해서 이해할 필요가 있었다.&lt;/li&gt;
  &lt;li&gt;다행히 이런 부분에 대해서 연구하신 분들이 많아서, 우리는 2차원에서 발생하는 원형 사이의 충돌량에 대한 공식을 사용하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;nx&quot;&gt;caculateCollisionScala&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;speedA&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;speedB&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;massA&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;massB&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;repulsiveForce&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;speedA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;massB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;speedB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;speedA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;massA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;massB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;repulsiveForce&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;REPULSIVE_COEFFICIENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;COLLISION_COEFFICIENT&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;amp;blogId=eunmikorea&amp;amp;logNo=221344714516&quot;&gt;참고자료 : 물체의 운동과 2차원 충돌&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;문제-발생&quot;&gt;문제 발생&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;충돌력이 예상보다 강했고, 세부조정을 거치면서 마찰력만으로는 충돌력을 서서히 감소시켜주는 것이 어렵다는 것을 알게되었다.&lt;/li&gt;
  &lt;li&gt;충돌력을 줄이기 위해서는 초기 벡터를 줄여야했지만, 그렇게 하면 중앙으로 모이는 것이 너무 느렸다. 충돌력과 별개로 반발계수를 추가하여 실험해봤지만 맘에 드는 모양으로 움직이지 않았다.&lt;/li&gt;
  &lt;li&gt;이 모든 부분을 해결해줄 수 있는 것은 중력이라는 판단을 할 수 있었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;중력-구현&quot;&gt;중력 구현&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/206631059-1d64ed84-2279-4eb9-b7ce-568b1eaba8b5.gif&quot; alt=&quot;204280957-1cda2268-5290-414f-a50b-a91830ef28cf&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;중력을 구현하고 나니 원하는 모양에 가까워졌다.&lt;/li&gt;
  &lt;li&gt;다만 아직은 와글와글보다는 왁자지껄에 가까운 것이 만들어졌다.&lt;/li&gt;
  &lt;li&gt;미세한 수치 조정을 거치면 원하는 결과가 생길 수 있을 것 같았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;결과&quot;&gt;결과&lt;/h1&gt;

&lt;h3 id=&quot;결과물&quot;&gt;결과물&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/206632520-50e4d3a2-3158-4f71-aa76-890331a45dec.gif&quot; alt=&quot;image2&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;미세한 수치 조정을 거치고, transition을 통해서 성능 문제도 해결하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;성능-비교&quot;&gt;성능 비교&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;여러 성능 비교를 하면서 알게 된 것은 적은 움직임 연산에서는 차라리 DOM과 리액트 리렌더링이 나을 수 있다는 것이었다.&lt;/li&gt;
  &lt;li&gt;결국 canvas를 그리기 위해서는 requestAnimationFrame이나 setInterval의 간격을 짧게 주어서 매 프레임마다 충돌연산이 되어야하는데, 거기에서 소모되는 CPU 연산 비용이 아주 크기 때문에 DOM의 개수가 최소 세자리수가 되지 않는다면 리액트 리렌더링을 하는 것이 CPU 사용량의 성능이 훨씬 좋다는 것이었다.&lt;/li&gt;
  &lt;li&gt;심지어 세자리수가 되더라도 연산해야하는 충돌량이 늘어나기 때문에, 리액트 리렌더링에서 transition을 통해 버블 차트의 움직임을 최적화시키고 나니 canvas를 통해 애니메이션을 만드는 것보다 성능이 훨씬 좋았다.&lt;/li&gt;
  &lt;li&gt;버블 200개 기준 canvas로 requestAnimationFrame을 사용하면 CPU 사용량이 90%를 넘어갔지만, 리렌더링 + transition, setInterval 0.5s를 사용하면 움직임도 부드럽고 GPU도 더 많이 사용하며 CPU 사용량도 12%로 충분했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;의의&quot;&gt;의의&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;리액트의 설계 원칙을 공부하면 JS에 대해 더 깊게 이해할 수 있다고는 생각했었지만, 막상 해보고 나니 UI로직과 연산 로직이 분리되는 것이 얼마나 중요한지 다시 느낄 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 06 Dec 2022 00:00:00 +0900</pubDate>
        <link>http://vangona.github.io/posts/circlepacker-physics</link>
        <guid isPermaLink="true">http://vangona.github.io/posts/circlepacker-physics</guid>
        
        <category>와글와글</category>
        
        <category>2차원 배치</category>
        
        <category>물리엔진</category>
        
        
        <category>Projects</category>
        
      </item>
    
      <item>
        <title>프로젝트 리더로 도전하기, 와글와글 개발기</title>
        <description>&lt;h1 id=&quot;프로젝트-리더로-도전하기-와글와글-개발기&quot;&gt;&lt;center&gt;프로젝트 리더로 도전하기, 와글와글 개발기&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;-week01-서로를-알아가기&quot;&gt;👨‍👨‍👧‍👧 Week01. 서로를 알아가기&lt;/h2&gt;

&lt;h3 id=&quot;생각이-많은-사람들&quot;&gt;생각이 많은 사람들&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;undefined가 모인 배경에는 ‘근거있는 선택’이 있었습니다. 주제를 먼저 정한 것이 아니라, 프로젝트에 임하는 마음가짐이 같은 사람들이 모였습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;아이디어가-넘쳤습니다&quot;&gt;아이디어가 넘쳤습니다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;많은 아이디어가 공유되는 것은 좋았지만, 그로인해 기획동안 회의가 샌다는 의견이 팀 내에 공유되었습니다.&lt;/li&gt;
  &lt;li&gt;역할과 규칙이 꼭 필요해졌습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;역할과-규칙을-만듭시다&quot;&gt;역할과 규칙을 만듭시다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;프로젝트 리더는 프로젝트의 전체 리딩을 맡고, 프론트엔드와 백엔드 각각의 파트 리더를 선정하여 각 파트의 진행을 맡았습니다. 또한 일정과 문서 기록 담당을 한 명 두어서 프로젝트 전체 리딩에 빈틈이 생기지 않도록 했습니다.&lt;/li&gt;
  &lt;li&gt;규칙도 정했습니다. 다만, 규칙이 오버엔지니어링이 되지 않도록 첫주차에는 틀을 정하는데에 중점을 두고 세부사항은 이후에 논의하기로 했습니다.&lt;/li&gt;
  &lt;li&gt;프로젝트 기간 동안, 평일 코어시간동안 게더타운에 모여서 함께 소통하면서 코딩하기로 결정되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;개발환경과-코딩-컨벤션을-만듭시다&quot;&gt;개발환경과 코딩 컨벤션을 만듭시다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;개발환경, 개발 도구, 코딩 컨벤션, Github 규칙 같은 것들을 정했습니다. 규칙을 정해야하는 이유에 대해서는 바빠지면 바빠질수록 더 깊게 느끼게 되었습니다.&lt;/li&gt;
  &lt;li&gt;내가 맡은 부분이 아니더라도, 코드 리뷰를 하여 다양한 분야의 지식 공유를 진행했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-week02-협업에-익숙해지기&quot;&gt;🤼 Week02. 협업에 익숙해지기&lt;/h2&gt;

&lt;h3 id=&quot;파트-분리&quot;&gt;파트 분리&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;각자의 영역에 도전하고 싶은 부분들이 많았기 때문에, 백엔드와 프론트엔드를 나누어서 개발했습니다.&lt;/li&gt;
  &lt;li&gt;다만 작은 팀에서 일이 너무 분리되지 않도록, 파트별 기록과 진행 상황 공유를 통해서 서로의 진행상황을 꾸준히 공유했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;트러블-슈팅을-정리합시다&quot;&gt;트러블 슈팅을 정리합시다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;팀 프로젝트 기간 동안은 특히 더, 단순한 구현보다는 과정이 더 중요하다는 의견이 있었습니다.&lt;/li&gt;
  &lt;li&gt;각자의 트러블 슈팅을 정리하면 단순히 코드 리뷰 때 읽을 수 없는 과정을 이해할 수 있다고 생각이 들어서 트러블 슈팅을 정리하기 시작했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;구현보다-의사결정이-중요합니다--마무리-스크럼&quot;&gt;구현보다 의사결정이 중요합니다 : 마무리 스크럼&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;시간이 갈수록 협업은 단순한 개인 개발과는 다른 것이라는 걸 느껴갔습니다. 구현보다는 의사결정과 그것의 싱크를 맞추는 것이 중요했습니다.&lt;/li&gt;
  &lt;li&gt;하루가 종료되고, 마무리 스크럼을 진행하기로 했습니다.&lt;/li&gt;
  &lt;li&gt;이를 통해서 하루 동안 어떤 작업이 진행되었는지, 내일을 위해 어떤 작업을 추가로 진행할 것인지 나누었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;차량은-생산성을-높여줍니다--유머와-여유의-탄생&quot;&gt;차량은 생산성을 높여줍니다 : 유머와 여유의 탄생&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/69471032/202074041-da91a700-e87a-4ce9-a380-41eb96044131.png&quot; alt=&quot;https://user-images.githubusercontent.com/69471032/202074041-da91a700-e87a-4ce9-a380-41eb96044131.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;개발 주간이 시작되자, 각자 긴장감이 높았습니다.&lt;/li&gt;
  &lt;li&gt;그러던 중 게더타운에 고카트가 있다는 것을 알게되었는데, 그 뒤로 카트는 저희의 슬리퍼가 되었습니다.&lt;/li&gt;
  &lt;li&gt;단순히 게임 내의 요소보다는 긴장된 회의가 끝난 이후 서로의 긴장을 푸는 장치가 되어주었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기술적인-도전이란-무엇일까&quot;&gt;기술적인 도전이란 무엇일까?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;이때부터 팀 내에서 기술적인 도전과 탐구는 무엇인지에 대한 이야기를 나누기 시작했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-week03-컨디션-관리-유머와-여유-챙기기&quot;&gt;💁 Week03. 컨디션 관리, 유머와 여유 챙기기&lt;/h2&gt;

&lt;h3 id=&quot;컨디션-관리의-중요성&quot;&gt;컨디션 관리의 중요성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;3주차가 되자, 컨디션 관리의 중요성이 나타나기 시작했습니다. 다들 긴장이 많이 되었었고, 긴장감은 판단력을 흐리게 만들었습니다.&lt;/li&gt;
  &lt;li&gt;아침에 일부러 TMI를 나누거나 낮잠시간을 만들기도 했습니다. 단순히 휴식하는 것이 아니라, 충분히 회고하기 위함이었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;wiki-작성&quot;&gt;Wiki 작성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;기획의 싱크를 맞출 때가 한 번 되었다고 생각했습니다.&lt;/li&gt;
  &lt;li&gt;다 같이 Wiki의 내용을 읽으며, 기획에 대한 생각이 다른 부분이 있다면 나누고 싱크를 맞췄습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;github을-더-적극적으로-활용합시다&quot;&gt;Github을 더 적극적으로 활용합시다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Github의 Issue가 Feature만을 관리하기 위해 사용되고 있다는 이슈가 나뉘어졌습니다.&lt;/li&gt;
  &lt;li&gt;Github을 더 적극적으로 활용하면, 서로의 작업 진행상황이 공유되지 않아도 실시간으로 알 수 있다는 의견이 공유되었습니다.&lt;/li&gt;
  &lt;li&gt;매일 하나의 Issue를 닫고, PR을 날리자는 규칙이 세워졌습니다. 그 정도로 나눌 수 없다면, 조금 더 작업 단위를 나누어서 서로가 작업 상태를 공유하자는 의견이 공유되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;절반에서-돌아보기--포스트-모템&quot;&gt;절반에서 돌아보기 : 포스트 모템&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;우리는 충분한 기술적 도전을 하고 있는가에 대해서 나뉘어지기도 했습니다.&lt;/li&gt;
  &lt;li&gt;그렇게 제대로 가지 못하고 있는 부분에 대해서는 남은 시간을 계산하고 조금 되돌아가기도, 더 나아가야할 부분이 있다면 방향을 잡기도 했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-week04-문서-레이아웃-개선&quot;&gt;📒 Week04. 문서 레이아웃 개선&lt;/h2&gt;

&lt;h3 id=&quot;문서-레이아웃-수정&quot;&gt;문서 레이아웃 수정&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;컨디션 관리가 어려워지자, 서로의 문서를 읽기 어려워졌습니다. 이를 해결하기 위해서 중요한 문서는 depth를 낮추거나 전체 레이아웃을 수정했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;github-issue를-더-열심히-쓰기&quot;&gt;Github Issue를 더 열심히 쓰기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Github Issue를 통해서 서로에게 필요한 트러블을 공유할 수 있다는 생각이 들었습니다.&lt;/li&gt;
  &lt;li&gt;단순히 전달만으로는 휘발될 수 있는 트러블들을 Issue에 발행하면서 전달하자는 이야기가 공유되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;문서로-대화하기&quot;&gt;문서로 대화하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;API 명세와 Figma를 가지고 대화하는 시간이 점점 더 많아졌습니다.&lt;/li&gt;
  &lt;li&gt;이에 따라 이전까지 있던 워크 플로우에 불필요한 부분을 줄여내기도 했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;의사결정에-대해-다시-알리기&quot;&gt;의사결정에 대해 다시 알리기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;단순히 구현에 매몰되면 안된다는 것이 꾸준히 공유되었습니다.&lt;/li&gt;
  &lt;li&gt;피곤해지면, 목적과 우선순위를 잃고 구현에 매몰되기도 했습니다.&lt;/li&gt;
  &lt;li&gt;그런 때가 있다면 낮잠을 자서라도 판단력을 명료하게 만들자는 이야기가 공유되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;️-week05-열심히-달리기&quot;&gt;🏃‍♀️ Week05. 열심히 달리기&lt;/h2&gt;

&lt;h3 id=&quot;커뮤니케이션-적응&quot;&gt;커뮤니케이션 적응&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;5주차가 되니, 다들 협업에 조금 익숙해졌습니다.&lt;/li&gt;
  &lt;li&gt;이전보다 말하는 것이 줄어도 문서와 Github을 통해서 서로의 맥락을 이해할 수 있었고, 지금까지 쌓아놓은 것들 덕분에 커뮤니케이션 비용이 줄어들었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;컨디션과-멘탈관리&quot;&gt;컨디션과 멘탈관리&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;할 일은 많았습니다.&lt;/li&gt;
  &lt;li&gt;프로젝트가 막바지에 이르니 프로젝트 소개와 이력서, 마감기한이 끝나가는 기능들을 마무리 짓는 것에 집중했습니다.&lt;/li&gt;
  &lt;li&gt;이 과정에서 판단력이 흐려지지 않도록 컨디션과 멘탈 관리에 대한 이야기들이 나뉘어졌습니다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 06 Dec 2022 00:00:00 +0900</pubDate>
        <link>http://vangona.github.io/posts/as-a-project-leader</link>
        <guid isPermaLink="true">http://vangona.github.io/posts/as-a-project-leader</guid>
        
        <category>와글와글</category>
        
        
        <category>Projects</category>
        
      </item>
    
      <item>
        <title>개발과 인문학 두번째 모임, 사람이라는 객체</title>
        <description>&lt;h1 id=&quot;-사람이라는-객체&quot;&gt;👥 사람이라는 객체&lt;/h1&gt;

&lt;aside&gt;
💡 오늘의 한 줄 : 고3 때 친구들과 하는게 많았는데, 대학에 진학하며 그 분리를 겪기가 힘들었다. OOP에서 응집도를 높여야하는 것처럼, 나라는 사람도 의존성을 낮추고 스스로로서 응집도를 높이는 것이 필요하지는 않은가 생각이 든다.

&lt;/aside&gt;

&lt;h2 id=&quot;-어디까지-소프트웨어라고-할-수-있을까&quot;&gt;🌐 어디까지 소프트웨어라고 할 수 있을까?&lt;/h2&gt;

&lt;h3 id=&quot;시와-코드-변수명-짓기&quot;&gt;시와 코드, 변수명 짓기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;같은 점 : 메세지를 추상화 시켜서 단어에 담는다.&lt;/li&gt;
  &lt;li&gt;다른 점 : 시는 의미를 각자가 다르게 느껴도 되지만, 변수명은 명확한 의미가 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;노하우가-생길-수-있는-모든-것은-소프트웨어-아닐까&quot;&gt;노하우가 생길 수 있는 모든 것은 소프트웨어 아닐까?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;체계화해서 반복 사용할 수 있는 것들이 노하우가 되는데, 그렇다면 그것을 아키텍처로 생각한다면 노하우가 생길 수 있는 모든 것은 소프트웨어가 아닐까?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;이름-짓기와-상수-enum-활용&quot;&gt;이름 짓기와 상수 Enum 활용&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;상담에는 이름 짓기라는 기법이 존재하는데, 내가 회피하고 있거나 구체화시키지 못하고 있는 대상에 이름을 지어서 그것을 스스로에게 분리해서 바라볼 수 있도록 한다. 이것도 상수 모듈을 분리해서 Enum을 사용하는 것 같지 않을까?&lt;/li&gt;
  &lt;li&gt;장점 : 식별이 편해진다. ⇒ 반복적으로 발생하는 삶의 문제에 대해 이름을 지으면, 비슷한 장점을 가질 수 있지 않을까?&lt;/li&gt;
  &lt;li&gt;단점 : 선언해야한다. ⇒ 삶의 문제에 이름을 지었을 때 추상화를 잘못한다면, 해당 문제가 아닌 문제들도 해당 변수명으로 합리화 할 수도 있겠다. (ex. 나는 MBTI가 ~라서 그래.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;소프트웨어는-문제-해결-이-방법론을-삶에-적용시키면-개발도-더-빨리-늘지-않을까&quot;&gt;소프트웨어는 문제 해결, 이 방법론을 삶에 적용시키면 개발도 더 빨리 늘지 않을까?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;무언가를 통해 내 삶의 문제가 해결되면 빨리 배운다. 어른들이 말씀하시던, ‘필요하면 다 하게 되어있다.’라는 말씀이 이런 것 아니었을까-&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;️-프로그래밍-언어와-커뮤니케이션&quot;&gt;🗣️ 프로그래밍 언어와 커뮤니케이션&lt;/h2&gt;

&lt;h3 id=&quot;여러가지-프로그래밍-언어&quot;&gt;여러가지 프로그래밍 언어&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;여러가지 프로그래밍 언어를 객체화해본다면 서로의 차이점을 통해 각 언어의 본질에 접근해볼 수 있지 않을까?&lt;/li&gt;
  &lt;li&gt;캠프동안 처음으로 JS를 접했었는데, 마구 튀어다니는 JS가 처음에는 적응이 어려웠지만 적응되니 너무 좋았다. 이제는 C언어가 사람이었다면 너무 깐깐해서 친해지기 힘들었을 것 같다. 😄&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;얄미운-사람-얄미운-js&quot;&gt;얄미운 사람, 얄미운 JS&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;사람과 JS만 암묵적인 타입변환을 하는 것 같다. 사람도 JS도 종종 야속하다.&lt;/li&gt;
  &lt;li&gt;반대로, 그렇기 때문에 사람간의 커뮤니케이션에 신뢰가 중요한 것처럼 JS 코드도 예측가능하게 써야겠다는 생각이 든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사람을-소프트웨어로-접근한다면&quot;&gt;👤 사람을 소프트웨어로 접근한다면?&lt;/h2&gt;

&lt;h3 id=&quot;나를-소프트웨어로-본다면-우리는-다들-버전업하면서-살고-있지는-않을까&quot;&gt;나를 소프트웨어로 본다면, 우리는 다들 버전업하면서 살고 있지는 않을까?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;다들 메서드나 프로퍼티를 추가하면서 살고 있는 것 아닐까?&lt;/li&gt;
  &lt;li&gt;흑역사는 리팩토링하면서 새로운 나를 맞이하고, 이전에 가지고 있었던 생각들을 고쳐나가며 버전업하는 것은 아닐까?
/ 참고자료
&lt;a href=&quot;https://www.notion.so/aebc9668a1f74539a477ea5f4397bf5b&quot;&gt;https://innovative-phosphorus-e4b.notion.site/aebc9668a1f74539a477ea5f4397bf5b&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인간도-머신러닝과-비슷한-것-같다&quot;&gt;인간도 머신러닝과 비슷한 것 같다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;우리도 많은 경험과 사례, 표본을 통해서 성장해야 좋은 방향으로 성장 할 수 있지 않을까?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;여러-메서드가-의존하고-있는-프로퍼티에-큰-수정이-발생하면-여러-문제가-생긴다-사람도-이런-경우가-있을까&quot;&gt;여러 메서드가 의존하고 있는 프로퍼티에 큰 수정이 발생하면 여러 문제가 생긴다. 사람도 이런 경우가 있을까?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;사람은 누구나 ‘인간’이라는 객체에 의해 여러 메소드와 프로퍼티를 기본적으로 상속받는다.&lt;/li&gt;
  &lt;li&gt;객체에서 this.property를 이용해서 메서드를 작성한 경우, 해당 프로퍼티의 내용이나 자료형등이 바뀌게 되면 해당 프로퍼티에 의존하는 여러 메서드가 영향을 받게되는데 사람이 이런 경우는 없을까?&lt;/li&gt;
  &lt;li&gt;키가 확 자라나면, 갑자기 변한 내 삶의 환경들에 적응하기 어려웠다. 큰 변화가 생기면, 삶에서도 리팩토링이 필요했던 것 같다.&lt;/li&gt;
  &lt;li&gt;그럼 삶에서 했던 리팩토링을 이용해서 코드 리팩토링을 쉽게할 수 있는 방법은 없을까?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;사람만-스스로-버그-수정과-리팩토링을-한다&quot;&gt;사람만 스스로 버그 수정과 리팩토링을 한다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;병원이나 물리치료를 받는 것이 이슈를 잡아서 리팩토링 하는 것 같다.&lt;/li&gt;
  &lt;li&gt;그런데 코드와 다른 점이 있다면, 인간만 직접 리팩토링을 하는 것 같다.&lt;/li&gt;
  &lt;li&gt;또한 이런 리팩토링의 접근도 다 달랐다. 자신의 문제를 해결하기 위해서 누군가는 공부를 하고, 누군가는 운동을 하고, 누군가는 또 다른 것들을 했다.&lt;/li&gt;
  &lt;li&gt;사람을 개인의 상위 객체로 표현한다면, 우리는 어떤 메서드나 프로퍼티를 오버라이딩 하면서 살고 있는건 아닐까?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-사람을-객체화해본다면&quot;&gt;💊 사람을 객체화해본다면?&lt;/h2&gt;

&lt;h3 id=&quot;사람을-객체로-접근&quot;&gt;사람을 객체로 접근&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;개인이 인간이라는 상위클래스에게서 상속 받는 것이 무엇이 있을까?&lt;/li&gt;
  &lt;li&gt;인간이라는 클래스가 동물이라는 상위클래스에게서 상속 받은 것이 아니라, 인간이라는 클래스에서 작성된 메서드가 무엇이 있을까? 이게 인간과 동물을 나눠줄 수 있지 않을까?&lt;/li&gt;
  &lt;li&gt;그럼 개인이 인간이라는 클래스에게서 상속 받은 것과 아닌 것은 무엇이 있을까?&lt;/li&gt;
  &lt;li&gt;이 고민이 고민을 위한 고민이 아니라 실제 삶에 적용할 수 있으려면 어떤 이야기를 나눠보아야할까?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;아까-나왔던-사람과-의존성으로-돌아가봅시다&quot;&gt;아까 나왔던, 사람과 의존성으로 돌아가봅시다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;상위 클래스인 ‘인간’에서 새로운 메서드와 프로퍼티를 가지는 것이 개성이 만들어지는 과정 아닐까?&lt;/li&gt;
  &lt;li&gt;개인이 상위 클래스에서 받은 ‘상식’, ‘사회가 가지고 있는 통념’ 같은 것들에 스스로가 강하게 결합되어 있으면 개성을 가지거나 확장하기 어려워지는 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;생각-정리와-매몰&quot;&gt;&lt;strong&gt;생각 정리와 매몰&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;사회 속 상징등에 갇히게 되는 경우가 많았다. 아는 만큼 보는 것도 같은 맥락인 것 같다.&lt;/li&gt;
  &lt;li&gt;무언가가 인상적이었다면 그것에 끼어맞추며 생각하게 되는 경우도 있는 것 같다.&lt;/li&gt;
  &lt;li&gt;종종 내가 정리하고 정의한 것에 매몰되어서 합리화하는 경우도 생겼다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;내가-안다고-생각하지만-사실-상속받은-것&quot;&gt;&lt;strong&gt;내가 안다고 생각하지만 사실 상속받은 것&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;종종 개인은 상위클래스에게서 무얼 받았는지 잊고, 내가 아는 것이라고 생각하는 경우도 있는 것 같다.&lt;/li&gt;
  &lt;li&gt;사람은 정보은닉이 너무 잘되어 있는 것 같다. 문제는 this에서도 그 정보를 모른다는 점이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;사람-클래스의-의존성&quot;&gt;사람 클래스의 의존성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;사람의 의존은 다른 사람들과 가장 크게 연관되어 있는 것 같다.&lt;/li&gt;
  &lt;li&gt;어디에 크게 의존하고 있는지 인지하는게 중요한 것 같다. 이것을 인지할 수 있는게, 말해보자면 의존성 주입의 가능 아닐까?&lt;/li&gt;
  &lt;li&gt;그럼 사람이 의존하는 관계에는 어떤게 있을까?&lt;/li&gt;
  &lt;li&gt;내가 소중히 생각하는 많은 것에 결합도가 높아지는 것 같다. 사람 뿐만 아니라 책임감, 사랑, 우정, 애착이 가는것까지 나라는 사람이 의존해서 결합도가 높아진 것 같다.&lt;/li&gt;
  &lt;li&gt;고3 때 친구들과 하는게 많았는데, 대학에 진학하며 그 분리를 겪기가 힘들었다. OOP에서 응집도를 높여야하는 것처럼, 나라는 사람도 의존성을 낮추고 스스로로서 응집도를 높이는 것이 필요하지는 않은가 생각이 든다.&lt;/li&gt;
  &lt;li&gt;누군가라는 외부에 의존하게 되면 나라는 객체를 수정하는게 쉽지 않아지는 것 같다. 의존성 주입이 중요한 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;️-소감&quot;&gt;❤️ 소감&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;다들 코딩에 미쳐있다. 광기가 눈에 보인다.&lt;/li&gt;
  &lt;li&gt;다들 광기가 있었다. 다른데에서는 하지 못하는 말들을 할 수 있어서 좋았다.&lt;/li&gt;
  &lt;li&gt;언어유희가 많아서 재미있었고, 다들 비유를 잘했다. 앞으로 많이 배우고 싶다.&lt;/li&gt;
  &lt;li&gt;처음에는 긴가민가 했는데, 재미있었다. ‘어디서 나라는 사람이 추상화가 잘되어있어.’ 같은 말을 할까&lt;/li&gt;
  &lt;li&gt;재미있었습니다. (이후 관계와 의존성 주제 발제)&lt;/li&gt;
  &lt;li&gt;일상에서 얻을 수 있는 영감과, 응집도 있는 집단 속 광기에서 얻을 수 있는 영감이 다르다고 생각한다. 광기 속 많은 영감을 얻을 수 있어서 너무 좋았다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 23 Sep 2022 00:00:00 +0900</pubDate>
        <link>http://vangona.github.io/posts/human-as-object</link>
        <guid isPermaLink="true">http://vangona.github.io/posts/human-as-object</guid>
        
        <category>객체지향프로그래밍</category>
        
        
        <category>Humanities</category>
        
      </item>
    
      <item>
        <title>DeepDiveJS, Chapter 09. 타입 변환과 단축 평가</title>
        <description>&lt;h1 id=&quot;09장-타입-변환과-단축-평가&quot;&gt;[09장. 타입 변환과 단축 평가]&lt;/h1&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;h3 id=&quot;️-자바스크립트의-알아서-잘하는-타입변환&quot;&gt;✏️ 자바스크립트의 알아서 잘하는 타입변환&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;  근데 알아서 하는건 종종 오해를 낳는다. 그러니 자바스크립트가 어떤 때에 알아서 잘하는지 하는지 아는게 필요하다.&lt;/p&gt;

&lt;p&gt;자바스크립트에는 두 가지의 타입 변환이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;명시적 타입 변환 (타입 캐스팅)&lt;/li&gt;
  &lt;li&gt;암묵적 타입 변환 (타입 강제 변환)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;명시적 타입변환은 toString() 메서드와 같이, 타입을 변환하는 것을 명시적으로 명령하는 것이다.&lt;/p&gt;

&lt;p&gt;반대로 암묵적 타입 변환은, 명시적으로 명령하지 않지만 자바스크립트 엔진이 맥락을 평가하고 타입을 변환하는 것을 말한다.&lt;/p&gt;

&lt;p&gt;예를 들어, ‘1’ + 1;이라는 문장은 ‘1’이 암묵적으로 숫자형으로 변환되어서 2라고 평가되어진다.&lt;/p&gt;

&lt;p&gt;각각의 타입변환에는 장단점이 존재한다.&lt;/p&gt;

&lt;p&gt;앞의 내용에서 언급했듯이 암묵적이고, 맥락에 의한 처리는 종종 오해를 발생시킨다. 다만, 가독성이 좋아질 수 있다.&lt;/p&gt;

&lt;p&gt;암묵적 타입변환을 효과적으로 사용하기 위해서, 각각의 타입에서 암묵적 타입변환이 어떻게 발생하는지 아는 것이 도움된다.&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;h3 id=&quot;️-반복되는건-짧게-쓸-수-있도록-합의합시다&quot;&gt;✏️ 반복되는건 짧게 쓸 수 있도록 합의합시다.&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;  타입이나 논리를 확인 후 그에 따라 명령을 실행하는 문에 매번 같은 조건문에서 값을 비교하는 것은 효율적이지 못할 것이다. 이를 위해서 자바스크립트는 미리 합의를 통해 몇가지 단축평가 문법을 제안하여 개발자로 하여금 코드를 작성하기 쉽게 돕는다.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Jul 2022 00:00:00 +0900</pubDate>
        <link>http://vangona.github.io/posts/deepdivejs-type-casting</link>
        <guid isPermaLink="true">http://vangona.github.io/posts/deepdivejs-type-casting</guid>
        
        <category>DeepDiveJS</category>
        
        <category>Javascript</category>
        
        
        <category>languages</category>
        
      </item>
    
      <item>
        <title>DeepDiveJS, Chapter 13. 스코프</title>
        <description>&lt;h1 id=&quot;13장-스코프&quot;&gt;[13장. 스코프]&lt;/h1&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;h3 id=&quot;️-말이-쓰일-범위를-모르면-오해가-생깁니다&quot;&gt;✏️ 말이 쓰일 범위를 모르면 오해가 생깁니다.&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;  pr이라는 단어를 듣는다면 뭐가 떠오를까?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;마케팅에서는 PR을 Public Relations로 말하며, 대중과의 긍정적인 관계를 형성하기 위해 하는 활동을 말한다.&lt;/li&gt;
  &lt;li&gt;헬스에서는 PR을 Personal Record라고해서 개인 기록을 말한다.&lt;/li&gt;
  &lt;li&gt;개발에서는 PR을 Pull Request의 의미로 사용하며, 깃허브에서 내 작업물이 브랜치로의 병합될 수 있도록 요청하는 것을 말한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;사람은 편의를 위해 축약어나 단어를 사용하고, 범위가 넓어지게 되면 동음이의어가 생기게 된다.&lt;/p&gt;

&lt;p&gt;코드도 똑같다. 코드에서도 변수의 사용범위가 뒤죽박죽이고 변수를 읽는 순서가 다르다면 오해가 생길 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;h3 id=&quot;️-이를-위해-스코프scope가-있어요&quot;&gt;✏️ 이를 위해 스코프(Scope)가 있어요.&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;  이러한 오해를 막기위해서 스코프가 존재한다.&lt;/p&gt;

&lt;p&gt;변수를 선언하면 해당 변수가 사용될 수 있는 스코프 내의 객체에 식별자로 등록되게 되며, 변수를 호출했을 때 호출한 스코프에 해당 변수가 없다면 하나씩 상위 스코프를 탐색하게 된다.&lt;/p&gt;

&lt;p&gt;이러한 이유로 사용상의 편의를 위해 무턱대로 전역변수에 변수를 선언하는 것은 좋지 않다. 이는 14장. 전역 변수의 문제점에서 다뤄진다.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Jul 2022 00:00:00 +0900</pubDate>
        <link>http://vangona.github.io/posts/deepdivejs-scope</link>
        <guid isPermaLink="true">http://vangona.github.io/posts/deepdivejs-scope</guid>
        
        <category>DeepDiveJS</category>
        
        <category>Javascript</category>
        
        
        <category>languages</category>
        
      </item>
    
  </channel>
</rss>
